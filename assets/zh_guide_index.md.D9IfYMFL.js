import{_ as i,c as s,o as e,ae as t}from"./chunks/framework.osJJb4L7.js";const k=JSON.parse('{"title":"介绍","description":"","frontmatter":{},"headers":[],"relativePath":"zh/guide/index.md","filePath":"zh/guide/index.md"}'),l={name:"zh/guide/index.md"};function r(n,a,p,h,o,d){return e(),s("div",null,a[0]||(a[0]=[t(`<h1 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h1><p>mini-rspack 是一个概念验证性的 JavaScript 打包工具，它使用 Rust 实现核心功能并提供类似 webpack 的 JavaScript API。它展示了如何使用 Rust 和 Node.js 原生模块创建高性能的 JavaScript 工具。</p><h2 id="为什么选择-mini-rspack" tabindex="-1">为什么选择 mini-rspack？ <a class="header-anchor" href="#为什么选择-mini-rspack" aria-label="Permalink to &quot;为什么选择 mini-rspack？&quot;">​</a></h2><p>现代 JavaScript 打包工具如 webpack 功能强大，但在处理大型应用程序时可能会变慢。通过在 Rust 中实现核心功能，mini-rspack 旨在提供：</p><ol><li><strong>更好的性能</strong>：Rust 的速度和内存效率可以显著提高打包时间</li><li><strong>熟悉的 API</strong>：兼容 webpack 的 API 使开发者容易采用</li><li><strong>学习资源</strong>：简化的实现有助于理解打包工具架构</li></ol><h2 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h2><p>mini-rspack 遵循与 webpack 类似的概念：</p><h3 id="编译器-compiler" tabindex="-1">编译器 (Compiler) <a class="header-anchor" href="#编译器-compiler" aria-label="Permalink to &quot;编译器 (Compiler)&quot;">​</a></h3><p><code>Compiler</code> 是 mini-rspack 的主入口点。它管理编译过程并为插件提供钩子。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rspack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;mini-rspack&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> compiler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rspack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options);</span></span></code></pre></div><h3 id="编译-compilation" tabindex="-1">编译 (Compilation) <a class="header-anchor" href="#编译-compilation" aria-label="Permalink to &quot;编译 (Compilation)&quot;">​</a></h3><p><code>Compilation</code> 表示应用程序的单次构建。它包含构建过程中生成的模块、块和资源。</p><h3 id="模块-module" tabindex="-1">模块 (Module) <a class="header-anchor" href="#模块-module" aria-label="Permalink to &quot;模块 (Module)&quot;">​</a></h3><p><code>Module</code> 表示依赖图中的一个模块。它包含有关模块源代码、依赖关系以及如何处理它的信息。</p><h3 id="加载器-loader" tabindex="-1">加载器 (Loader) <a class="header-anchor" href="#加载器-loader" aria-label="Permalink to &quot;加载器 (Loader)&quot;">​</a></h3><p>加载器转换模块的内容。它们可用于处理非 JavaScript 文件或转换 JavaScript 代码。</p><h3 id="插件-plugin" tabindex="-1">插件 (Plugin) <a class="header-anchor" href="#插件-plugin" aria-label="Permalink to &quot;插件 (Plugin)&quot;">​</a></h3><p>插件扩展 mini-rspack 的功能。它们可以利用编译器和编译提供的钩子来修改构建过程。</p><h2 id="下一步" tabindex="-1">下一步 <a class="header-anchor" href="#下一步" aria-label="Permalink to &quot;下一步&quot;">​</a></h2><ul><li><a href="/mini-rspack/zh/guide/getting-started.html">快速开始</a>：学习如何安装和使用 mini-rspack</li><li><a href="/mini-rspack/zh/guide/configuration.html">配置</a>：探索配置选项</li><li><a href="/mini-rspack/zh/guide/plugins.html">插件</a>：学习如何使用和创建插件</li><li><a href="/mini-rspack/zh/guide/loaders.html">加载器</a>：学习如何使用和创建加载器</li></ul>`,20)]))}const u=i(l,[["render",r]]);export{k as __pageData,u as default};
